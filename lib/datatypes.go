package goschedule

import (
	"encoding/json"
	"fmt"
	"html"
	"html/template"
	"regexp"
	"strings"
)

// Position provides the start and end indices of a struct
// extracted from a document.
type position struct {
	Start int
	End   int
}

// A College is a UW college that has many departments
type College struct {
	Name         string
	Abbreviation string `pk:"true"`
	position     `ignore:"true"`
}

// A Department is a UW department that has many classes.
type Dept struct {
	CollegeKey   string `fk:"College"`
	Name         string
	Abbreviation string `pk:"true"`
	Link         string
}

// ExtractAbbreviation extracts a department abbreviation from content (assumed
// to be a class index of a department) and sets the Dept.Abbreviation attribute.
//
// Returns an error if no department abbreviation was found.
func (d *Dept) ScrapeAbbreviation(content string) error {
	if match := regexp.MustCompile(`(?i)<a name=.+?>(.+?)&nbsp;&nbsp; .*?</a>`).FindStringSubmatch(content); match == nil || len(match) < 2 {
		return fmt.Errorf("No match found in content")
	} else {
		abbreviation := html.UnescapeString(match[1])
		abbreviation = strings.ToLower(strings.Replace(abbreviation, " ", "", -1))
		d.Abbreviation = abbreviation
	}
	return nil
}

// A Class is UW class that has many sections.
type Class struct {
	DeptKey          string `fk:"Dept"`
	AbbreviationCode string `pk:"true"`
	Abbreviation     string
	Code             string
	Title            string
	Description      string
	position         `ignore:"true"`
}

// DescriptionHTML outputs non-escaped HTML of a Class.Description for use in a template.
func (c Class) DescriptionHTML() template.HTML {
	root := "http://www.washington.edu"
	description := c.Description
	description = strings.TrimPrefix(description, "<BR>")
	// Add root index to links
	re := `<a href="`
	offset := len(re)
	// For each link, insert the root at the index of the match, adding offset generated by previous link insertions
	if matches := regexp.MustCompile(re).FindAllStringIndex(strings.ToLower(description), -1); matches != nil {
		for i, match := range matches {
			perLinkOffset := i * len(root)
			description = description[:(match[0]+offset+perLinkOffset)] + root + description[(match[0]+offset+perLinkOffset):]
		}
	}
	return template.HTML(description)
}

// A Sect is a UW section.
type Sect struct {
	ClassKey     string `fk:"Class"`
	Restriction  string
	SLN          string `pk:"true"`
	Section      string
	Credit       string
	MeetingTimes string // JSON representation
	Instructor   string
	Status       string
	TakenSpots   int64
	TotalSpots   int64
	Grades       string
	Fee          string
	Other        string
	Info         string
}

// GetMeetingTimes parses the JSON representation of meeting
// times from the Section.
// Returns a slice of MeetingTime structs, or an empty slice
// if the section has no MeetingTime's.
func (s Sect) GetMeetingTimes() ([]MeetingTime, error) {
	var meetingTimes []MeetingTime
	if err := json.Unmarshal([]byte(s.MeetingTimes), &meetingTimes); err != nil {
		return nil, err
	}
	return meetingTimes, nil
}

// IsQuizSection indicates if this Sect is a quiz section.
func (s Sect) IsQuizSection() bool {
	if s.Credit == "QZ" {
		return true
	} else {
		return false
	}
}

// IsOpen indicates if this Sect has open spots.
func (s Sect) IsOpen() bool {
	if s.TotalSpots-s.TakenSpots < 1 {
		return false
	} else {
		return true
	}
}

// IsFreshmen indicates if this Sect is restricted to freshmen by looking
// for key phrases/words in Sect.Info.
func (s Sect) IsFreshmen() bool {
	keyPhrases := []string{
		// "freshmen interest grp students only",
		// "freshman interest grp students only",
		// "freshmen interest grp only",
		// "freshman interest grp only",
		// "freshmen interest group students only",
		// "freshman interest group students only",
		// "freshmen interest group only",
		// "freshman interest group only",
		// "open only to entering freshmen",
		// "open only to entering freshman",
		// "open to entering freshmen only",
		// "open to entering freshman only",
		// "opening only to entering freshmen",
		"freshmen",
		"freshman",
	}
	info := strings.Replace(
		strings.ToLower(s.Info), "\n", " ", -1)

	for _, v := range keyPhrases {
		if strings.Contains(info, v) {
			return true
		}
	}
	return false
}

// IsWithdrawal indicates if this Sect pending withdrawal by looking for key
// phrases/words in Sect.Info.
func (s Sect) IsWithdrawal() bool {
	keyPhrases := []string{"withdrawl", "withdrawal"}
	info := strings.ToLower(s.Info)
	for _, v := range keyPhrases {
		if strings.Contains(info, v) {
			return true
		}
	}
	return false
}

// GetRestriction returns a map of possible restriction symbols to booleans depending
// on if they apply to this Sect.
func (s Sect) GetRestriction() []map[string]bool {
	allTokens := []string{"Restr", "IS", ">"}
	tokens := make([]map[string]bool, len(allTokens))
	for i, v := range allTokens {
		if strings.Contains(s.Restriction, v) {
			tokens[i] = map[string]bool{v: true}
		} else {
			tokens[i] = map[string]bool{v: false}
		}
	}
	return tokens
}

// GetGradesTokens returns a map of possible grade tokens to booleans depending
// on if they apply to this Sect.
func (s Sect) GetGradesTokens() []map[string]bool {
	allTokens := []string{"CR/NC"}
	tokens := make([]map[string]bool, len(allTokens))
	for i, v := range allTokens {
		if strings.Contains(s.Credit, v) {
			tokens[i] = map[string]bool{v: true}
		} else {
			tokens[i] = map[string]bool{v: false}
		}
	}
	return tokens
}

// GetOtherTokens returns a map of possible other tokens to booleans depending
// on if they apply to this Sect.
func (s Sect) GetOtherTokens() []map[string]bool {
	allTokens := []string{"D", "H", "J", "R", "S", "W", "%", "#"}
	tokens := make([]map[string]bool, len(allTokens))
	for i, v := range allTokens {
		if strings.Contains(s.Other, v) {
			tokens[i] = map[string]bool{v: true}
		} else {
			tokens[i] = map[string]bool{v: false}
		}
	}
	return tokens
}

// A MeetingTime represents when a Sect is held. Some Sect's have multiple
// meeting times.
type MeetingTime struct {
	Days     string
	Time     string
	Building string
	Room     string
}

// MapDays returns a map of possible days to booleans depending on what
// days this Section is held.
func (m MeetingTime) MapDays() map[string]bool {
	days := strings.ToLower(m.Days)
	dayMap := make(map[string]bool)
	daysSlice := []string{"m", "w", "f", "th", "t"}
	for _, day := range daysSlice {
		if strings.Contains(days, day) {
			dayMap[day] = true
			days = strings.Replace(days, day, "", -1)
		}
	}
	return dayMap
}
